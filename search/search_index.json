{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Trino Gateway is a load balancer, proxy server, and configurable routing  gateway for multiple Trino clusters.</p>"},{"location":"#use-cases-advantages-and-features","title":"Use cases, advantages, and features","text":"<ul> <li>Use of a single connections URL for client tool users with workload   distribution across multiple connectors.</li> <li>Automatic routing of queries to clusters for specific workloads.</li> <li>No-downtime upgrades for Trino clusters behind the Trino Gateway in a   blue/green model.</li> <li>Transparent change of capacity of Trino clusters behind the Trino Gateway   without user interruptions.</li> </ul>"},{"location":"#other-resources","title":"Other resources","text":"<ul> <li>Trino Gateway announment blog post</li> <li> Many clusters and only one   gateway presentation at Trino Summit 2023</li> <li>Lyft blog post</li> <li>Pinterest blog post</li> <li>Zomato blog post</li> <li>Shopify blog post</li> </ul>"},{"location":"design/","title":"Design","text":"<p>Trino Gateway is composed of the following main components:</p> <ol> <li>BaseApp provides boilerplate code to add/remove pluggable components    with config and metrics registration module. Located in the     <code>io.trino.gateway.baseapp</code> package of the <code>gateway-ha</code> module.</li> </ol> <p></p> <ol> <li>ProxyServer is a library built on top of jetty proxy which provides a    proxy server with a pluggable proxy-handler. Located in the    <code>io.trino.gateway.proxyserver</code> package of the <code>gateway-ha</code> module.</li> </ol> <p></p> <ol> <li>Trino Gateway acts as container for proxy-server and plugs in    ProxyHandlers to provide proxy, routing and load balancing functionalities. It    also exposes few end points and UI to activate, deactivate backends and view    query history for recently submitted queries. Located in the    <code>io.trino.gateway</code> package of the <code>gateway-ha</code> module.</li> </ol> <p></p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#build-requirements","title":"Build requirements","text":"<ul> <li>Mac OS X or Linux</li> <li>Java 21+, 64-bit</li> <li>Docker</li> </ul>"},{"location":"development/#running-trino-gateway-in-your-ide","title":"Running Trino Gateway in your IDE","text":"<p>The best way to run Trino Gateway for development is to run the <code>TrinoGatewayRunner</code> class. You need to run <code>io.trino.gateway.TrinoGatewayRunner.main()</code> method on your IDE or execute the following command:</p> <pre><code>./mvnw test-compile exec:java -pl gateway-ha -Dexec.classpathScope=test -Dexec.mainClass=\"io.trino.gateway.TrinoGatewayRunner\"\n</code></pre>"},{"location":"development/#build-and-run","title":"Build and run","text":""},{"location":"development/#locally","title":"Locally","text":"<p>This project requires Java 21. Note that higher version of Java have not been verified and may run into unexpected issues.</p> <p>Run <code>./mvnw clean install</code> to build <code>trino-gateway</code>. VM options required for compilation and testing are specified in <code>.mvn/jvm.config</code>.</p> <p>Edit the configuration file <code>gateway-ha-config.yml</code> in the <code>gateway-ha</code> folder and update the mysql db information.</p> <pre><code>cd gateway-ha/target/\njava --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED -jar gateway-ha-{{VERSION}}-jar-with-dependencies.jar server ../gateway-ha-config.yml\n</code></pre>"},{"location":"development/#in-docker","title":"In Docker","text":"<p>Follow the separate instructions for building the container and running Trino Gateway with docker compose from the <code>README.md</code> file in the <code>docker</code> folder.</p>"},{"location":"development/#common-run-failures","title":"Common Run Failures","text":"<p>If you encounter a <code>Failed to connect to JDBC URL</code> error with the MySQL backend, this may be due to newer versions of Java disabling certain algorithms when using SSL/TLS, in particular <code>TLSv1</code> and <code>TLSv1.1</code>. This causes <code>Bad handshake</code> errors when connecting to the MySQL server. You can avoid this by enabling <code>TLSv1</code> and <code>TLSv1.1</code> in your JDK, or by adding <code>sslMode=DISABLED</code> to your connection string.</p> <p>To enable TLS1 and 1.1, in</p> <pre><code>${JAVA_HOME}/jre/lib/security/java.security\n</code></pre> <p>search for <code>jdk.tls.disabledAlgorithms</code>, it should look something like this:</p> <pre><code>jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \\\n    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \\\n    include jdk.disabled.namedCurves\n</code></pre> <p>Remove <code>TLSv1, TLSv1.1</code> and redo the above steps to build and run <code>trino-gateway</code>.</p> <p>If you see test failures while building <code>trino-gateway</code> or in an IDE, please run <code>mvn process-classes</code> to instrument javalite models which are used by the tests. Refer to the javalite-examples for more details.</p>"},{"location":"development/#contributing","title":"Contributing","text":"<p>Want to help build Trino Gateway? Check out our contributing documentation</p>"},{"location":"development/#release-process","title":"Release process","text":"<p>A full release process consists of the following steps:</p> <p>Merge the pull request for the release notes and pull the changes locally:</p> <pre><code>cd trino-gateway\ngit checkout main\ngit pull\n</code></pre> <p>Run a Maven release build:</p> <pre><code>./mvnw clean release:prepare release:perform\n</code></pre> <p>A successful release build performs the necessary commits, and pushes the binaries to Maven Central staging.</p> <p>Close and release the staging repository, and wait until the sync to Central is completed. Confirm the presence of the artifacts at https://repo.maven.apache.org/maven2/io/trino/gateway/gateway-ha/.</p> <p>Ensure that you are logged into Docker Hub  with suitable permissions, and run the container release script with the version  number that was just released,  for example <code>6</code>:</p> <pre><code>docker/release-docker.sh 6\n</code></pre> <p>Once completed, verify the availability at https://hub.docker.com/r/trinodb/trino-gateway.</p> <p>Announce the release on Trino Slack and LinkedIn.</p>"},{"location":"docs/","title":"Documentation development","text":"<p>The Trino Gateway documentation uses markdown source files, MkDocs with the  material theme for rendering, and GitHub pages for hosting.</p> <p>The following sections contain minimal helpful tips to get started. More  details are available in the following resources:</p> <ul> <li>Material for MkDocs website</li> <li>MkDocs website</li> </ul>"},{"location":"docs/#writing-documentation","title":"Writing documentation","text":"<p>Content is written as markdown files in the <code>docs</code> folder.</p> <p>Writing style guidelines are identical to the Trino documentation and  website.</p> <p>Refer to the  reference docs from Material for MkDocs for syntax information.  </p>"},{"location":"docs/#running-site-locally","title":"Running site locally","text":"<p>Install <code>python</code> and <code>pipx</code>, for example with brew.</p> <p>Install mkdocs-material and all required dependencies:</p> <pre><code>pipx install --install-deps mkdocs-material\n</code></pre> <p>Start the local site in the project root folder:</p> <pre><code>cd trino-gateway\nmkdocs serve\n</code></pre> <p>Access the site in your browser at http://127.0.0.1:8000/</p> <p>Edit the site sources as desired and refresh pages as needed. Some changes  require a restart of mkdocs.</p>"},{"location":"docs/#configuring-mkdocs","title":"Configuring MKDocs","text":"<p>MkDocs is configured in <code>mkdocs.yml</code>. Refer to the source, the  Material for MkDocs website  and the MkDocs website for more information.</p>"},{"location":"gateway-api/","title":"Gateway API","text":""},{"location":"gateway-api/#add-or-update-a-backend","title":"Add or update a backend","text":"<p>```$xslt curl -X POST http://localhost:8080/entity?entityType=GATEWAY_BACKEND \\  -d '{  \"name\": \"trino-3\",         \"proxyTo\": \"http://localhost:8083\",         \"active\": true,         \"routingGroup\": \"adhoc\"     }'</p> <pre><code>\nIf the backend URL is different from the `proxyTo` URL (for example if they are\ninternal vs. external hostnames). You can use the optional `externalUrl` field\nto override the link in the Active Backends page.\n\n```$xslt\ncurl -X POST http://localhost:8080/entity?entityType=GATEWAY_BACKEND \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }'\n</code></pre>"},{"location":"gateway-api/#get-all-backends","title":"Get all backends","text":"<p><code>curl -X GET http://localhost:8080/entity/GATEWAY_BACKEND</code> ```$xslt [     {         \"name\": \"trino-1\",         \"proxyTo\": \"http://localhost:8081\",         \"active\": true,         \"routingGroup\": \"adhoc\",         \"externalUrl\": \"http://localhost:8081\"     },     {         \"name\": \"trino-2\",         \"proxyTo\": \"http://localhost:8082\",         \"active\": true,         \"routingGroup\": \"adhoc\",         \"externalUrl\": \"http://localhost:8082\"     },     {         \"name\": \"trino-3\",         \"proxyTo\": \"http://localhost:8083\",         \"active\": true,         \"routingGroup\": \"adhoc\",         \"externalUrl\": \"http://localhost:8084\"     } ]</p> <pre><code>\n## Delete a backend\n\n```$xslt\ncurl -X POST -d \"trino3\" http://localhost:8080/gateway/backend/modify/delete\n</code></pre>"},{"location":"gateway-api/#deactivate-a-backend","title":"Deactivate a backend","text":"<p>```$xslt curl -X POST http://localhost:8080/gateway/backend/deactivate/trino-2</p> <pre><code>\n## Get all active backends\n\n`curl -X GET http://localhost:8080/gateway/backend/active`\n\n</code></pre> <p>[     {         \"name\": \"trino-1\",         \"proxyTo\": \"http://localhost:8081\",         \"active\": true,         \"routingGroup\": \"adhoc\",         \"externalUrl\": \"http://localhost:8081\"     } ] ```</p>"},{"location":"gateway-api/#activate-a-backend","title":"Activate a backend","text":"<p><code>curl -X POST http://localhost:8080/gateway/backend/activate/trino-2</code></p>"},{"location":"installation/","title":"Installation","text":"<p>Trino Gateway is distributed as an executable JAR file. The release notes contain links to download specific versions. Alternatively, you can look at the development instructions to build the JAR file or use the TrinoGatewayRunner for local testing. The quickstart guide contains instructions for running the application locally. </p> <p>Following are instructions for installing Trino Gateway for production environments.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>Consider the following requirements for your Trino Gateway installation.</p>"},{"location":"installation/#java","title":"Java","text":"<p>Trino Gateway requires a Java 21 runtime. Older versions of Java can not be used. Newer versions might work but are not tested.</p> <p>Verify the Java version on your system with <code>java -version</code>.</p>"},{"location":"installation/#operating-system","title":"Operating system","text":"<p>No specific operating system is required. All testing and development is performed with Linux and MacOS.</p>"},{"location":"installation/#processor-architecture","title":"Processor architecture","text":"<p>No specific processor architecture is required, as long as a suitable Java distribution is installed.  </p>"},{"location":"installation/#backend-database","title":"Backend database","text":"<p>Trino Gateway requires a MySQL or PostgreSQL database.</p> <p>Use the following scripts in the <code>gateway-ha/src/main/resources/</code> folder to initialize the database:</p> <ul> <li><code>gateway-ha-persistence-mysql.sql</code> for MySQL</li> <li><code>gateway-ha-persistence-postgres.sql</code> for PostgreSQL</li> </ul> <p>The files are also included in the JAR file.</p>"},{"location":"installation/#trino-clusters","title":"Trino clusters","text":"<p>The proxied Trino clusters behind the Trino Gateway must support the Trino JDBC driver and the Trino REST API for cluster and node health information. Typically, this means that Trino versions 354 and higher should work, however newer Trino versions are strongly recommended.</p> <p>Trino-derived projects and platforms may work if the Trino JDBC driver and the REST API are supported. For example, Starburst Galaxy and Starburst Enterprise are known to work. Trino deployments with the Helm chart and other means on various cloud platforms, such as Amazon EKS also work. However Amazon Athena does not work since it uses alternative, custom protocols and lacks the concept of individual clusters.</p>"},{"location":"installation/#trino-configuration","title":"Trino configuration","text":"<p>From a users perspective Trino Gateway acts as a transparent proxy for one  or more Trino clusters. The following Trino configuration tips should be  taken into account for all clusters behind the Trino Gateway.</p> <p>Process forwarding must be enabled:</p> <pre><code>http-server.process-forwarded=true\n</code></pre> <p>Without this setting, first requests go from the user to Trino Gateway and then to Trino correctly. However, the URL for subsequent next URIs for more results in a query provided by Trino is then using the local URL of the Trino cluster, and not the URL of the Trino Gateway. This circumvents the Trino Gateway for all these requests, and is contrary to the purpose of using the Trino Gateway. In scenarios, where the local URL of the Trino cluster is private to the Trino cluster on the DNS/network level, these following calls might not work at all for users.</p> <p>This setting is also required for Trino to authenticate in the case TLS is  terminated at the Trino Gateway. Normally it refuses to authenticate plain HTTP  requests, but if <code>http-server.process-forwarded=true</code> it authenticates over  HTTP if the request includes <code>X-Forwarded-Proto: HTTPS</code>.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After downloading or building the JAR, rename it to <code>gateway-ha.jar</code>, and place it in a directory with read and write access such as <code>/opt/trinogateway</code>.</p> <p>Copy the example config file <code>gateway-ha-config.yml</code> from the <code>gateway-ha/</code> directory into the same directory, and update the configuration as needed.</p> <p>Each component of the Trino Gateway has a corresponding node in the configuration YAML file.</p>"},{"location":"installation/#configure-routing-rules","title":"Configure routing rules","text":"<p>Find more information in the routing rules documentation.</p>"},{"location":"installation/#configure-logging","title":"Configure logging  <p>Path to <code>log.properties</code> must be set via <code>log.levels-file</code> JVM options like <code>-Dlog.levels-file=etc/log.properties</code>.</p> <p>Use the <code>log.*</code> properties from the Trino logging properties documentation for further configuration.</p>","text":""},{"location":"installation/#proxying-additional-paths","title":"Proxying additional paths <p>By default, Trino Gateway only proxies requests to paths starting with <code>/v1/statement</code>, <code>/v1/query</code>, <code>/ui</code>, <code>/v1/info</code>, <code>/v1/node</code>, <code>/ui/api/stats</code> and <code>/oauth</code>.</p> <p>If you want to proxy additional paths, you can add them by adding the <code>extraWhitelistPaths</code> node to your configuration YAML file:</p> <pre><code>extraWhitelistPaths:\n  - \"/ui/insights\"\n  - \"/api/v1/biac\"\n  - \"/api/v1/dataProduct\"\n  - \"/api/v1/dataproduct\"\n  - \"/ext/faster\"\n</code></pre>","text":""},{"location":"installation/#running-trino-gateway","title":"Running Trino Gateway","text":"<p>Start Trino Gateway with the following java command in the directory of the JAR and YAML files:</p> <pre><code>java -XX:MinRAMPercentage=50 -XX:MaxRAMPercentage=80 \\\n    --add-opens=java.base/java.lang=ALL-UNNAMED \\\n    --add-opens=java.base/java.net=ALL-UNNAMED \\\n    -jar gateway-ha.jar server gateway-config.yml\n</code></pre>"},{"location":"installation/#helm","title":"Helm <p>Helm manages the deployment of Kubernetes applications by templating Kubernetes resources with a set of Helm charts. The Trino Gateway Helm chart consists  of the following components:</p> <ul> <li>A <code>config</code> node for general configuration</li> <li><code>dataStoreSecret</code>, <code>backendStateSecret</code> and <code>authenticationSecret</code> for    providing sensitive configurations through Kubernetes secrets, </li> <li>Standard Helm options such as <code>replicaCount</code>, <code>resources</code> and <code>ingress</code>.</li> </ul> <p>The default <code>values.yaml</code> found in the <code>helm/trino-gateway</code> folder includes basic configuration options as an example. For a simple deployment, proceed with  the following steps:</p> <p>Create a yaml file containing the configuration for your <code>datastore</code>:</p> <pre><code>cat &lt;&lt; EOF &gt; datastore.yaml\ndataStore:\n   jdbcUrl: jdbc:postgresql://yourdatabasehost:5432/gateway\n   user: postgres\n   password: secretpassword\n   driver: org.postgresql.Driver\nEOF\n</code></pre> <p>Create a Kubernetes secret from this file:</p> <pre><code>kubectl create secret generic datastore-yaml --from-file datastore.yaml --dry-run=client -o yaml | kubectl apply -f -\n</code></pre> <p>Create a values override with a name such as <code>values-override.yaml</code> and reference this secret in the <code>backendStateSecret</code> node:</p> <pre><code>backendStateSecret:\n    name: \"datastore-yaml\"\n    key: \"datastore.yaml\"\n</code></pre> <p>When a Secret is created with the <code>--from-file</code> option, the filename is used as the key. Finally, you can deploy Trino Gateway with the chart from the root  of this repository:</p> <pre><code>helm install tg --values values-override.yaml helm/trino-gateway \n</code></pre> <p>Secrets for <code>authenticationSecret</code> and <code>backendState</code> can be provisioned similarly. Alternatively,  you can directly define the <code>config.backEndState</code>  node in <code>values-override.yaml</code> and leave <code>backendStateSecret</code> undefined.  However, a Secret is recommended to protect the  database credentials required for this  configuration.</p>","text":""},{"location":"installation/#additional-options","title":"Additional options","text":"<p>To implement routing rules, create a ConfigMap from your routing rules yaml definition:</p> <pre><code>kubectl create cm routing-rules --from-file your-routing-rules.yaml\n</code></pre> <p>Then mount it to your container:</p> <pre><code>volumes:\n    - name: routing-rules\n      configMap:\n          name: routing-rules\n          items:\n              name: your-routing-rules.yaml\n              path: your-routing-rules.yaml\n\nvolumeMounts:\n    - name: routing-rules\n      mountPath: \"/etc/routing-rules/your-routing-rules.yaml\"\n      subPath: your-routing-rules.yaml\n</code></pre> <p>Ensure that the <code>mountPath</code> matches the <code>rulesConfigPath</code> specified in your configuration. Note that the <code>subPath</code> is not strictly necessary, and if it  is not specified the file is mounted at <code>mountPath/&lt;configMap key&gt;</code>.  Kubernetes updates the mounted file when the ConfigMap is updated.</p> <p>Standard Helm o\u0153ptions such as <code>replicaCount</code>, <code>image</code>, <code>imagePullSecrets</code>,  <code>service</code>, <code>ingress</code> and <code>resources</code> are supported. These are defined in  <code>helm/values.yaml</code>. </p>"},{"location":"operation/","title":"Operation","text":"<p>The following aspects apply to managing Trino Gateway and the connected Trino clusters.</p>"},{"location":"operation/#query-history-ui-check-query-plans-etc","title":"Query History UI - check query plans etc.","text":"<p>Trino Gateway records history of recent queries and displays links to check query details page in respective trino cluster. </p>"},{"location":"operation/#admin-ui-add-and-modify-backend-information","title":"Admin UI - add and modify backend information","text":"<p>The admin page is used to configure the gateway to multiple backends. Existing backend information can also be modified using the same.</p> <p></p>"},{"location":"operation/#graceful-shutdown","title":"Graceful shutdown","text":"<p>Trino Gateway supports graceful shutdown of Trino clusters. Even when a cluster is deactivated, any submitted query states can still be retrieved based on the Query ID.</p> <p>To graceful shutdown a trino cluster without query losses, the steps are:</p> <ol> <li>Set the backend to deactivate state, this prevents any new incoming queries    from getting assigned to the backend.</li> <li>Poll the trino backend coorinator URL until the queued query count and the    running query count both hit 0.</li> <li>Terminate the trino Coordinator &amp; Worker Java process.</li> </ol> <p>To gracefully shutdown a single worker process, refer to the Trino  documentation for more details.</p>"},{"location":"operation/#query-routing-options","title":"Query routing options","text":"<ul> <li>The default router selects the backend randomly to route the queries. </li> <li>If you want to route the queries to the least loaded backend for a user i.e. backend with the least number of queries running or queued from a particular user, then use <code>QueryCountBasedRouter</code>, it can be configured by adding the module name  to config file's modules section like below</li> </ul> <pre><code>modules:\n  - io.trino.gateway.ha.module.HaGatewayProviderModule\n  - io.trino.gateway.ha.module.ClusterStateListenerModule\n  - io.trino.gateway.ha.module.ClusterStatsMonitorModule\n  - io.trino.gateway.ha.module.QueryCountBasedRouterProvider\n</code></pre> <ul> <li>The router works on the stats it receives from the clusters about the load i.e number queries queued and running on a cluster at regular intervals which can be configured like below. The default interval is 1 min</li> </ul> <pre><code>monitor:\n  taskDelaySeconds: 10\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>The scripts from this quickstart guide set up a local environment consisting of two Trino servers and a PostgreSQL database running in Docker, and a Trino Gateway server running in the host operating system. </p>"},{"location":"quickstart/#start-trino-gateway-server","title":"Start Trino Gateway server","text":"<p>The following script starts a Trino Gateway server using the  Quickstart configuration with the request service at http://localhost:9080, the application service at http://localhost:9081, and the Admin service at http://localhost:9082. It also starts a dockerized PostgreSQL database at localhost:5432.</p> <p>To start the server, copy the script below to a temporary directory  under the project root folder, and run it at the temporary directory.</p> <p>It  copies the following, necessary files to current directory:</p> <ul> <li>gateway-ha.jar</li> <li>gateway-ha-persistence-postgres.sql</li> <li>quickstart-config.yaml</li> </ul> <pre><code>#!/usr/bin/env sh\n\nVERSION=7\n\n# Copy necessary files to current directory\n\n# Check and get the Gateway Jar\nif [[ -f \"gateway-ha.jar\" ]]; then\n    echo \"Found gateway-har.jar file in current directory.\"\nelse\n    echo \"Failed to find gateway-ha.jar in current directory. Fetching version $VERSION from Maven Central repository.\"\n    curl https://repo1.maven.org/maven2/io/trino/gateway/gateway-ha/${VERSION}/gateway-ha-${VERSION}-jar-with-dependencies.jar -o ./gateway-ha.jar\nfi\n\n# Check and get the Config.yaml\nif [[ -f \"quickstart-config.yaml\" ]]; then\n    echo \"Found quickstart-config.yaml file in current directory.\"\nelse\n    cp ../docs/quickstart-config.yaml ./quickstart-config.yaml\nfi\n\n# Check and get the postgres.sql\nif [[ -f \"gateway-ha-persistence-postgres.sql\" ]]; then\n    echo \"Found gateway-ha-persistence-postgres.sql file in current directory.\"\nelse\n    cp ../gateway-ha/src/main/resources/gateway-ha-persistence-postgres.sql ./gateway-ha-persistence-postgres.sql\nfi\n\n#Check if DB is running\nif docker ps --format '{{.Names}}' | grep -q '^local-postgres$'; then\n    echo \"PostgreSQL database container 'localhost-postgres' is already running. Only starting Trino Gateway.\"\nelse\n    echo \"PostgreSQL database container 'localhost-postgres' is not running. Proceeding to initialize and run database server.\"\n    export PGPASSWORD=mysecretpassword\n    docker run -v \"$(pwd)\"/gateway-ha-persistence-postgres.sql:/tmp/gateway-ha-persistence-postgres.sql --name local-postgres -p 5432:5432 -e POSTGRES_PASSWORD=$PGPASSWORD -d postgres:latest\n    #Make sure the DB has time to initialize\n    sleep 5\n\n    #Initialize the DB\n    docker exec local-postgres psql -U postgres -h localhost -c 'CREATE DATABASE gateway'\n    docker exec local-postgres psql -U postgres -h localhost -d gateway -f /tmp/gateway-ha-persistence-postgres.sql\nfi\n\n\n#Start Trino Gateway server.\njava -Xmx1g --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED -jar ./gateway-ha.jar server ./quickstart-config.yaml\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill local-postgres &amp;&amp; docker rm local-postgres\nkill -5 $(jps | grep gateway-ha.jar | cut -d' ' -f1)\n</code></pre>"},{"location":"quickstart/#add-trino-backends","title":"Add Trino backends","text":"<p>This following script starts two dockerized Trino servers at  http://localhost:8081 and http://localhost:8082. It then adds them as backends to the Trino Gateway server started by the preceding script.</p> <pre><code>#!/usr/bin/env sh\n\n#Start a pair of trino servers on different ports\ndocker run --name trino1 -d -p 8081:8080 trinodb/trino\ndocker run --name trino2 -d -p 8082:8080 trinodb/trino\n\n#Add the trino servers as Gateway backends\ncurl -H \"Content-Type: application/json\" -X POST localhost:9080/gateway/backend/modify/add -d '{\"name\": \"trino1\",\n                                                                                                \"proxyTo\": \"http://localhost:8081\",\n                                                                                                \"active\": true,\n                                                                                                \"routingGroup\": \"adhoc\"\n                                                                                              }'\ncurl -H \"Content-Type: application/json\" -X POST localhost:9080/gateway/backend/modify/add -d '{\"name\": \"trino2\",\n                                                                                                \"proxyTo\": \"http://localhost:8082\",\n                                                                                                \"active\": true,\n                                                                                                \"routingGroup\": \"adhoc\"\n                                                                                              }'\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill trino1 &amp;&amp; docker rm trino1\ndocker kill trino2 &amp;&amp; docker rm trino2\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#trino-gateway-9-8-may-2024","title":"Trino Gateway 9 (8 May 2024)","text":"<p>JAR file gateway-ha-9-jar-with-dependencies.jar, Docker container <code>trinodb/trino-gateway:9</code></p> <ul> <li>Ensure inclusion of UI in JAR and container artifacts. (#337)</li> </ul>"},{"location":"release-notes/#trino-gateway-8-6-may-2024","title":"Trino Gateway 8 (6 May 2024)","text":"<p>JAR file gateway-ha-8-jar-with-dependencies.jar, Docker container <code>trinodb/trino-gateway:8</code></p> <ul> <li>Add support for configurable router policies. (#98)</li> <li>Add a router policy based on query count per cluster. (#98)</li> <li>Add a router policy for select paths based on cookie content. (#188)</li> <li>Support configuring access permissions for UI pages. (#296)</li> <li>Add Helm chart for Kubernetes deployments. (#87)</li> <li>Require Java 21 for build and runtime. (#225)</li> <li>Fix the <code>userInfo</code> resource to pass role information used by the API, so that   the webapp authentication matches the API authentication. (#310)</li> </ul>"},{"location":"release-notes/#trino-gateway-7-21-mar-2024","title":"Trino Gateway 7 (21 Mar 2024)","text":"<p>JAR file gateway-ha-7-jar-with-dependencies.jar, Docker container <code>trinodb/trino-gateway:7</code></p> <ul> <li>Replace user interface with a new modern UI. (#116)</li> <li>Improve logging configurability. Users must update to the    new logging configuration. (#260)</li> <li>Improve Trino cluster health check performance and remove authentication requirement    by using the <code>v1/info</code> endpoint. (#264)</li> <li>Fix query id tracking based on request querystring parsing. (#265)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#trino-gateway-6-16-feb-2024","title":"Trino Gateway 6 (16 Feb 2024)","text":"<p>JAR file gateway-ha-6-jar-with-dependencies.jar, Docker container <code>trinodb/trino-gateway:6</code></p> <ul> <li>Add Docker container build, publishing, and usage setup and instructions. (#86)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#trino-gateway-5-24-jan-2024","title":"Trino Gateway 5 (24 Jan 2024)","text":"<p>gateway-ha-5-jar-with-dependencies.jar</p> <ul> <li>Add support for OAuth 2 audience use. (#164)</li> <li>Add quickstart scripts and documentation. (#110)</li> <li>Add project logo. (#111)</li> <li>Prevent ignoring HTTP header configuration. (#100)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#trino-gateway-4-30-nov-2023","title":"Trino Gateway 4 (30 Nov 2023)","text":"<p>gateway-ha-4-jar-with-dependencies.jar</p> <ul> <li>Add support for configuring additional whitelisted URL paths. (#63)</li> <li>Improve flexibility of user and group name matching for authorization. (#32)</li> <li>Add support to use external URL for backend creation. (#76)</li> <li>Enable configuration of HTTP header size. (#67)</li> <li>Automatically set JDBC configuration parameter for TLS when connecting to   clusters for monitoring. (#71)</li> <li>Modernize application and remove potential for undiscovered bugs and security   issues with update of many core dependencies. (#59)</li> <li>Avoid failure when unhandled OIDC properties are present. (#69)</li> <li>Prevent failures resulting from reloading and parsing rules file. (#5)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#trino-gateway-3-26-sep-2023","title":"Trino Gateway 3 (26 Sep 2023)","text":"<p>gateway-ha-3-jar-with-dependencies.jar</p> <p>The first release of Trino Gateway is based on the  Presto Gateway 1.9.5 codebase (#4) with these additions:</p> <ul> <li>Add authentication and authorization with LDAP, OIDC and user list from config   file. (#9)</li> <li>Add support for user, admin and API roles. (#9)</li> <li>Add healthcheck for Trino backends using JDBC. (#9)</li> <li>Add TCP check for routing. (#9)</li> <li>Add logic to route requests only to healthy backends. (#13)</li> <li>Add PostgreSQL support for backend database. (#13)</li> <li>Allow routing of <code>/v1/node</code> endpoint URL. (#27)</li> <li>Filter logs for sensitive information. (#9)</li> <li>Require Java 17 for build and runtime. (#16)</li> <li>Deactivate clusters with zero workers. (#13)</li> <li>Remove concurrency issue from repeated rules file loading. (#9)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"resource-groups-api/","title":"Resource groups API","text":"<p>For resource group and selector apis, we can now specify a query parameter with the request supporting multiple trino databases for different trino backends. This allows a user to configure a db for every trino backend with their own resource groups and selector tables. To use this, just specify the query parameter ?useSchema= to the request. Example, to list all resource groups, <p>```$xslt curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}?useSchema=newdatabasename</p> <pre><code>\n## Add a resource group\n\nTo add a single resource group, specify all relevant fields in the body.\nResource group id should not be specified since the database should\nautoincrement it.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/resourcegroup/create \\\n -d '{\n        \"name\": \"resourcegroup1\", \\\n        \"softMemoryLimit\": \"100%\", \\\n        \"maxQueued\": 100, \\\n        \"softConcurrencyLimit\": 100, \\\n        \"hardConcurrencyLimit\": 100, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-resource-groups","title":"Get existing resource group(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing resource groups are fetched.</p> <p>```$xslt curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}</p> <pre><code>\n## Update a resource group\n\nSpecify all columns in the body, which will overwrite properties for the\nresource group with that specific resourceGroupId.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/resourcegroup/update \\\n -d '{  \"resourceGroupId\": 1, \\\n        \"name\": \"resourcegroup_updated\", \\\n        \"softMemoryLimit\": \"80%\", \\\n        \"maxQueued\": 50, \\\n        \"softConcurrencyLimit\": 40, \\\n        \"hardConcurrencyLimit\": 60, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-resource-group","title":"Delete a resource group","text":"<p>To delete a resource group, specify the corresponding resourceGroupId (type long).</p> <p>```$xslt curl -X POST http://localhost:8080/trino/resourcegroup/delete/{INSERT_ID_HERE}</p> <pre><code>\n## Add a selector\n\nTo add a single selector, specify all relevant fields in the body. Resource\ngroup id should not be specified since the database should autoincrement it.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/selector/create \\\n -d '{\n        \"priority\": 1, \\\n        \"userRegex\": \"selector1\", \\\n        \"sourceRegex\": \"resourcegroup1\", \\\n        \"queryType\": \"insert\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-selectorss","title":"Get existing selectors(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing selectors are fetched.</p> <p>```$xslt curl -X GET http://localhost:8080/trino/selector/read/{INSERT_ID_HERE}</p> <pre><code>\n## Update a selector\n\nTo update a selector, the existing selector must be specified with all relevant\nfields under \"current\". The updated version of that selector is specified under\n\"update\", with all relevant fields included. If the selector under \"current\"\ndoes not exist, a new selector will be created with the details under \"update\".\nBoth \"current\" and \"update\" must be included to update a selector.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/selector/update \\\n -d '{  \"current\": {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 1, \\\n            \"userRegex\": \"selector1\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": \"insert\" \\\n        },\n        \"update\":  {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 2, \\\n            \"userRegex\": \"selector1_updated\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": null \\\n        }\n}'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-selector","title":"Delete a selector","text":"<p>To delete a selector, specify all relevant fields in the body.</p> <p>```$xslt curl -X POST http://localhost:8080/trino/selector/delete \\  -d '{  \"resourceGroupId\": 1, \\         \"priority\": 2, \\         \"userRegex\": \"selector1_updated\", \\         \"sourceRegex\": \"resourcegroup1\", \\         \"queryType\": null \\      }'</p> <pre><code>\n## Add a global property\n\nTo add a single global property, specify all relevant fields in the body.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/globalproperty/create \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"1h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-global-properties","title":"Get existing global properties","text":"<p>If no name (type String) is specified, then all existing global properties are fetched.</p> <p>```$xslt curl -X GET http://localhost:8080/trino/globalproperty/read/{INSERT_NAME_HERE}</p> <pre><code>\n## Update a global property\n\nSpecify all columns in the body, which will overwrite properties for the global\nproperty with that specific name.\n\n```$xslt\ncurl -X POST http://localhost:8080/trino/globalproperty/update \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"2h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-global-property","title":"Delete a global property","text":"<p>To delete a global property, specify the corresponding name (type String).</p> <p><code>$xslt curl -X POST http://localhost:8080/trino/globalproperty/delete/{INSERT_NAME_HERE}</code></p>"},{"location":"routing-logic/","title":"Routing Logic","text":""},{"location":"routing-logic/#overview","title":"Overview","text":"<p>Trino Gateway checks incoming requests to see if they're related to previous  ones it handled. If they are, then Trino Gateway sends them to the same backend  that dealt with the earlier requests.</p> <p>If it is a new request, the Trino Gateway refers to Routing rules  to decide which group of backends, called a 'Routing Group,' should handle it.  It then picks a backend from that Routing Group to handle the request using  either an adaptive or round-robin strategy.</p> <p></p>"},{"location":"routing-logic/#sticky-routing","title":"Sticky routing","text":"<p>A request related to an ongoing process, or to state maintained on a single  backend cluster, must be routed to that backend for proper handling. Two  mechanisms for identifying related requests are currently implemented. By default, only routing based on query identifier is enabled.</p>"},{"location":"routing-logic/#routing-based-on-query-identifier-default","title":"Routing based on query identifier (default)","text":"<p>When a query is initiated through the Trino Gateway, the query id will be  extracted from the response and mapped to the backend that provided the  response. Any subsequent request containing that query id will be forwarded  to that backend. For example, to retrieve query results, the trino client  polls a URI of the form  <code>v1/statement/executing/queryid/nonce/counter</code>. The Trino Gateway will extract the queryid from this URI.</p>"},{"location":"routing-logic/#routing-based-on-cookies","title":"Routing based on cookies","text":"<p>OAuth2 authentication requires that the same backend is used for each step of  the handshake. When <code>gatewayCookieConfiguration.enabled</code> is set to true, a cookie  will be added to requests made to paths beginning with <code>/oauth2</code> unless they already have  a cookie present, which is used to route further <code>/oauth2/*</code> requests to the correct backend.  Cookies are not added to requests to <code>v1/*</code> and other Trino endpoints.</p> <p>Trino Gateway signs its cookies to ensure that they are not tampered with. You  must set a <code>cookieSigningSecret</code> string in your configuration</p> <pre><code>gatewayCookieConfiguration:\n    enabled: true\n    cookieSigningSecret: \"ahighentropystring\"\n</code></pre> <p>when making use of this feature. If you load balance request across multiple Trino Gateway instances, ensure each instance has the same <code>cookieSigningSecret</code>.</p> <p>The Trino Gateway handles standard Trino OAuth2 handshakes with no additional  configuration. If you are using a customized or commercial Trino distribution, then the paths used to define the OAuth handshake may be modified.</p> <p><code>routingPaths</code>: If the request URI starts with a path in this list, then * If no cookie is present, add a routing cookie * If a cookie is present, route the request to the backend defined by that cookie</p> <p><code>deletePaths</code>: If the request URI starts with a path in this list, return a response that instructs the client to delete the cookie.</p> <p>Additionally, the <code>lifetime</code> property sets the duration for which a cookie remains in  effect after creation. Ensure that it is greater than the time required to complete the handshake. Default <code>lifetime</code> is 10 minutes.</p> <p>These properties are defined under the <code>oauth2GatewayCookieConfiguration</code> node: </p> <pre><code>oauth2GatewayCookieConfiguration:\n  routingPaths:\n    - \"/oauth2\"\n    - \"/custom/oauth2/callback\"\n    - \"/alternative/oauth2/initiate\"\n  deletePaths:\n    - \"/custom/logout\"\n  lifetime: \"5m\"\n</code></pre>"},{"location":"routing-rules/","title":"Routing rules","text":"<p>Trino Gateway includes a routing rules engine.</p> <p>By default, Trino Gateway reads the <code>X-Trino-Routing-Group</code> request header to route requests. If this header is not specified, requests are sent to default routing group (adhoc).</p> <p>The routing rules engine feature enables you to write custom logic to route requests based on the request info such as any of the request headers. Routing rules are separated from Trino Gateway application code to a configuration file, allowing for dynamic rule changes.</p>"},{"location":"routing-rules/#defining-your-routing-rules","title":"Defining your routing rules","text":"<p>To express and fire routing rules, we use the easy-rules engine. These rules should be stored in a YAML file. Rules consist of a name, description, condition, and list of actions. If the condition of a particular rule evaluates to true, its actions are fired.</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>In the condition, you can access the methods of a HttpServletRequest object called <code>request</code>. There should be at least one action of the form <code>result.put(\\\"routingGroup\\\", \\\"foo\\\")</code> which says that if a request satisfies the condition, it should be routed to <code>foo</code>.</p> <p>The condition and actions are written in MVEL, an expression language with Java-like syntax. In most cases, users can write their conditions/actions in Java syntax and expect it to work. There are some MVEL-specific operators that could be useful though. For example, instead of doing a null-check before accessing the <code>String.contains</code> method like this:</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") != null &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\").contains(\"label=foo\")'\n</code></pre> <p>You can use the <code>contains</code> operator</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=foo\"'\n</code></pre> <p>If no rules match, then request is routed to adhoc.</p>"},{"location":"routing-rules/#execution-of-rules","title":"Execution of Rules","text":"<p>All rules whose conditions are satisfied will fire. For example, in the \"airflow\" and \"airflow special\" example rules given above, a query with source <code>airflow</code> and label <code>special</code> will satisfy both rules. The <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code> because of the order in which the rules of defined. If we swap the order of the rules, then we would possibly get <code>etl</code> instead, which is undesirable.</p> <p>One could solve this by writing the rules such that they're atomic (any query will match exactly one rule). For example we can change the first rule to</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") == null'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\n</code></pre> <p>This could be hard to maintain as we add more rules. To have better control over the execution of rules, we could use rule priorities and composite rules. Overall, with priorities, composite rules, and the constructs that MVEL support, you should likely be able to express your routing logic.</p>"},{"location":"routing-rules/#rule-priority","title":"Rule Priority","text":"<p>We can assign an integer value <code>priority</code> to a rule. The lower this integer is, the earlier it will fire. If the priority is not specified, the priority is defaulted to INT_MAX. We can add priorities to our airflow and airflow special rule like so:</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\npriority: 0\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\npriority: 1\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>Note that both rules will still fire. The difference is that we've guaranteed that the first rule (priority 0) is fired before the second rule (priority 1). Thus <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code>, so the <code>routingGroup</code> will always be <code>etl-special</code> in the end.</p> <p>Above, the more specific rules have less priority since we want them to be the last to set <code>routingGroup</code>. This is a little counterintuitive. To further control the execution of rules, for example to have only one rule fire, we can use composite rules.</p>"},{"location":"routing-rules/#composite-rules","title":"Composite Rules","text":"<p>First, please refer to easy-rule composite rules docs: https://github.com/j-easy/easy-rules/wiki/defining-rules#composite-rules</p> <p>Above, we saw how to control the order of rule execution using priorities. In addition to this, we could have only the first rule matched to be fired (the highest priority one) and the rest ignored. We can use <code>ActivationRuleGroup</code> to achieve this.</p> <pre><code>---\nname: \"airflow rule group\"\ndescription: \"routing rules for query from airflow\"\ncompositeRuleType: \"ActivationRuleGroup\"\ncomposingRules:\n  - name: \"airflow special\"\n    description: \"if query from airflow with special label, route to etl-special group\"\n    priority: 0\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\n    actions:\n      - 'result.put(\"routingGroup\", \"etl-special\")'\n  - name: \"airflow\"\n    description: \"if query from airflow, route to etl group\"\n    priority: 1\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\n    actions:\n      - 'result.put(\"routingGroup\", \"etl\")'\n</code></pre> <p>Note that the priorities have switched. The more specific rule has a higher priority, since we want it to be fired first. A query coming from airflow with special label is matched to the \"airflow special\" rule first, since it's higher priority, and the second rule is ignored. A query coming from airflow with no labels does not match the first rule, and is then tested and matched to the second rule.</p> <p>We can also use <code>ConditionalRuleGroup</code> and <code>ActivationRuleGroup</code> to implement an if/else workflow. The following logic in pseudocode:</p> <pre><code>if source == \"airflow\":\n  if clientTags[\"label\"] == \"foo\":\n    return \"etl-foo\"\n  else if clientTags[\"label\"] = \"bar\":\n    return \"etl-bar\"\n  else\n    return \"etl\"\n</code></pre> <p>Can be implemented with these rules:</p> <pre><code>name: \"airflow rule group\"\ndescription: \"routing rules for query from airflow\"\ncompositeRuleType: \"ConditionalRuleGroup\"\ncomposingRules:\n  - name: \"main condition\"\n    description: \"source is airflow\"\n    priority: 0 # rule with the highest priority acts as main condition\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\n    actions:\n      - \"\"\n  - name: \"airflow subrules\"\n    compositeRuleType: \"ActivationRuleGroup\" # use ActivationRuleGroup to simulate if/else\n    composingRules:\n      - name: \"label foo\"\n        description: \"label client tag is foo\"\n        priority: 0\n        condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=foo\"'\n        actions:\n          - 'result.put(\"routingGroup\", \"etl-foo\")'\n      - name: \"label bar\"\n        description: \"label client tag is bar\"\n        priority: 0\n        condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=bar\"'\n        actions:\n          - 'result.put(\"routingGroup\", \"etl-bar\")'\n      - name: \"airflow default\"\n        description: \"airflow queries default to etl\"\n        condition: \"true\"\n        actions:\n          - 'result.put(\"routingGroup\", \"etl\")'\n</code></pre>"},{"location":"routing-rules/#if-statements-mvel-flow-control","title":"If statements (MVEL Flow Control)","text":"<p>Above, we saw how we can use <code>ConditionalRuleGroup</code> and <code>ActivationRuleGroup</code> to implement and <code>if/else</code> workflow. We could also take advantage of the fact that MVEL supports <code>if</code> statements and other flow control (loops, etc). The following logic in pseudocode:</p> <pre><code>if source == \"airflow\":\n  if clientTags[\"label\"] == \"foo\":\n    return \"etl-foo\"\n  else if clientTags[\"label\"] = \"bar\":\n    return \"etl-bar\"\n  else\n    return \"etl\"\n</code></pre> <p>Can be implemented with these rules:</p> <pre><code>---\nname: \"airflow rules\"\ndescription: \"if query from airflow\"\ncondition: \"request.getHeader(\\\"X-Trino-Source\\\") == \\\"airflow\\\"\"\nactions:\n  - \"if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=foo\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-foo\\\")\n    }\n    else if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=bar\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-bar\\\")\n    }\n    else {\n      result.put(\\\"routingGroup\\\", \\\"etl\\\")\n    }\"\n</code></pre>"},{"location":"routing-rules/#enabling-routing-rules-engine","title":"Enabling routing rules engine","text":"<p>To enable routing rules engine, find the following lines in <code>gateway-ha-config.yml</code>. Set <code>rulesEngineEnabled</code> to True and <code>rulesConfigPath</code> to the path to your rules config file.</p> <pre><code>routingRules:\n  rulesEngineEnabled: true\n  rulesConfigPath: \"src/test/resources/rules/routing_rules.yml\" # replace with path to your rules config file\n</code></pre> <p>If there is error opening routing rules configuration file, then request is routed using routing group header <code>X-Trino-Routing-Group</code> as default.</p>"},{"location":"security/","title":"Security","text":"<p>Trino Gateway has its own security with its own authentication and authorization. These features are used only to authenticate and authorize its user interface and the APIs. All Trino-related requests are passed through to the Trino cluster without any authentication or authorization check in Trino Gateway.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>The authentication would happen on https protocol only. Add the <code>authentication:</code> section in the config file. The default authentication type is set using <code>defaultType: \"form\"</code> Following types of the authentications are supported.</p>"},{"location":"security/#oauthopenidconnect","title":"OAuth/OpenIDConnect","text":"<p>It can be configured as below</p> <pre><code>authentication:\n  defaultType: \"oauth\"\n  oauth:\n    issuer:\n    clientId:\n    clientSecret:\n    tokenEndpoint:\n    authorizationEndpoint:\n    jwkEndpoint:\n    redirectUrl:\n    redirectWebUrl: \n    userIdField:\n    scopes:\n      - s1\n      - s2\n      - s3\n</code></pre>"},{"location":"security/#note","title":"Note","text":"<ul> <li>For OAuth Trino Gateway uses <code>oidc/callback</code> where as Trino uses <code>oauth2</code> path</li> <li>Trino Gateway should have its own client id</li> <li>All the Trino backend clusters should have a single client id.</li> <li>Trino Gateway needs to pass thorugh the Trino Oauth2 requests only to one of the clusters.</li> <li>One way to handle it is to set a special rule like below:</li> </ul> <pre><code>  ---\n  name: \"Oauth requests\"\n  description: \"Oauth requests need to go to a single backed\"\n  condition: \"request.getRequestURI.startsWith(\\\"/oauth2\\\")\"\n  actions:\n    - \"result.put(\\\"routingGroup\\\", \\\"oauth2-handler\\\")\"\n</code></pre> <ul> <li>That also means you need to have a cluster with that routing group.</li> <li>It's ok to replicate an existing cluster backend record with a different name for that purpose.</li> </ul>"},{"location":"security/#formbasic-authentication","title":"Form/Basic authentication","text":"<p>The authentication happens with the pre-defined users from the configuration file. To define the preset user use the following section. Please note that 'privileges' can only be a combination of 'ADMIN', 'USER', and 'API', with '_' used for segmentation.</p> <pre><code>presetUsers:\n  user1:\n    password: &lt;password&gt;\n    privileges: ADMIN_USER\n  user2:\n    password: &lt;password&gt;\n    privileges: API\n</code></pre> <p>Also provide a random key pair in RSA format.</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#formldap","title":"Form/LDAP","text":"<p>LDAP requires both random key pair and config path for LDAP</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    ldapConfigPath: &lt;ldap_config_path&gt;\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#authorization","title":"Authorization","text":"<p>Trino Gateway supports the following roles in regex string format:</p> <ul> <li> <p>admin : Allows access to the Editor tab, which can be used to configure the   backends</p> </li> <li> <p>user : Allows access to the rest of the website</p> </li> <li> <p>api : Allows access to rest apis to configure the backends</p> </li> </ul> <p>Users with attributes next to the role will be giving those privileges the users. You can use the preset users defined in the yaml file.  LDAP Authorization is also supported by adding user attribute configs in file.</p> <ul> <li>Check out LDAPTestConfig.yml file for config details</li> </ul> <pre><code># Roles should be in regex format\nauthorization:\n  admin: (.*)ADMIN(.*)\n  user: (.*)USER(.*)\n  api: (.*)API(.*)\n  ldapConfigPath: '&lt;ldap_config_path&gt;'\n</code></pre> <p>The LDAP config file should have the following contents:</p> <pre><code>  ldapHost: '&lt;ldap sever&gt;'\n  ldapPort: &lt;port&gt;\n  useTls: &lt;true/false&gt;\n  useSsl: &lt;true/false&gt;\n  ldapAdminBindDn: &lt;&gt;\n  ldapUserBaseDn: &lt;&gt;\n  ldapUserSearch: &lt;&gt;\n  ldapGroupMemberAttribute: &lt;&gt;\n  ldapAdminPassword: &lt;&gt;\n  ldapTrustStorePath: &lt;for a secure ldap connectivity&gt;\n  ldapTrustStorePassword: '&lt;for a secure ldap connectivity&gt;'\n  poolMaxIdle: 8\n  poolMaxTotal: 8\n  poolMinIdle: 0\n  poolTestOnBorrow: true\n</code></pre>"},{"location":"security/#web-page-permissions","title":"Web page permissions","text":"<p>By default, all pages are accessible to all roles. To limit page access, you can set page permissions by pages  and <code>_</code> as separator field.</p> <p>The following pages are available: - <code>dashboard</code> - <code>cluster</code> - <code>resource-group</code> - <code>selector</code> - <code>history</code></p> <pre><code># admin/api can access all pages, while user can only access dashboard/history\npagePermissions:\n  admin: \n  user: dashboard_history \n  api: \n</code></pre>"}]}